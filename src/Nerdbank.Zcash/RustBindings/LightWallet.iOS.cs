// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.10.0+v0.29.4
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace uniffi.LightWallet;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
	public ulong capacity;
	public ulong len;
	public IntPtr data;

	public static RustBuffer Alloc(int size)
	{
		return _UniffiHelpers.RustCall(
			(ref UniffiRustCallStatus status) =>
			{
				var buffer = _UniFFILib.ffi_nerdbank_zcash_rust_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
				if (buffer.data == IntPtr.Zero)
				{
					throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
				}
				return buffer;
			}
		);
	}

	public static void Free(RustBuffer buffer)
	{
		_UniffiHelpers.RustCall(
			(ref UniffiRustCallStatus status) =>
			{
				_UniFFILib.ffi_nerdbank_zcash_rust_rustbuffer_free(buffer, ref status);
			}
		);
	}

	public static BigEndianStream MemoryStream(IntPtr data, long length)
	{
		unsafe
		{
			return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
		}
	}

	public BigEndianStream AsStream()
	{
		unsafe
		{
			return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len)));
		}
	}

	public BigEndianStream AsWriteableStream()
	{
		unsafe
		{
			return new BigEndianStream(
				new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(capacity), Convert.ToInt64(capacity), FileAccess.Write)
			);
		}
	}
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
	public int length;
	public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
	// Convert an FFI type to a C# type
	public abstract CsType Lift(FfiType value);

	// Convert C# type to an FFI type
	public abstract FfiType Lower(CsType value);

	// Read a C# type from a `ByteBuffer`
	public abstract CsType Read(BigEndianStream stream);

	// Calculate bytes to allocate when creating a `RustBuffer`
	//
	// This must return at least as many bytes as the write() function will
	// write. It can return more bytes than needed, for example when writing
	// Strings we can't know the exact bytes needed until we the UTF-8
	// encoding, so we pessimistically allocate the largest size possible (3
	// bytes per codepoint).  Allocating extra bytes is not really a big deal
	// because the `RustBuffer` is short-lived.
	public abstract int AllocationSize(CsType value);

	// Write a C# type to a `ByteBuffer`
	public abstract void Write(CsType value, BigEndianStream stream);

	// Lower a value into a `RustBuffer`
	//
	// This method lowers a value into a `RustBuffer` rather than the normal
	// FfiType.  It's used by the callback interface code.  Callback interface
	// returns are always serialized into a `RustBuffer` regardless of their
	// normal FFI type.
	public RustBuffer LowerIntoRustBuffer(CsType value)
	{
		var rbuf = RustBuffer.Alloc(AllocationSize(value));
		try
		{
			var stream = rbuf.AsWriteableStream();
			Write(value, stream);
			rbuf.len = Convert.ToUInt64(stream.Position);
			return rbuf;
		}
		catch
		{
			RustBuffer.Free(rbuf);
			throw;
		}
	}

	// Lift a value from a `RustBuffer`.
	//
	// This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
	// It's currently only used by the `FfiConverterRustBuffer` class below.
	protected CsType LiftFromRustBuffer(RustBuffer rbuf)
	{
		var stream = rbuf.AsStream();
		try
		{
			var item = Read(stream);
			if (stream.HasRemaining())
			{
				throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
			}
			return item;
		}
		finally
		{
			RustBuffer.Free(rbuf);
		}
	}
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
{
	public override CsType Lift(RustBuffer value)
	{
		return LiftFromRustBuffer(value);
	}

	public override RustBuffer Lower(CsType value)
	{
		return LowerIntoRustBuffer(value);
	}
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus
{
	public sbyte code;
	public RustBuffer error_buf;

	public bool IsSuccess()
	{
		return code == 0;
	}

	public bool IsError()
	{
		return code == 1;
	}

	public bool IsPanic()
	{
		return code == 2;
	}
}

// Base class for all uniffi exceptions
internal class UniffiException : System.Exception
{
	public UniffiException()
		: base() { }

	public UniffiException(string message)
		: base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
	public UndeclaredErrorException(string message)
		: base(message) { }
}

internal class PanicException : UniffiException
{
	public PanicException(string message)
		: base(message) { }
}

internal class AllocationException : UniffiException
{
	public AllocationException(string message)
		: base(message) { }
}

internal class InternalException : UniffiException
{
	public InternalException(string message)
		: base(message) { }
}

internal class InvalidEnumException : InternalException
{
	public InvalidEnumException(string message)
		: base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
	public UniffiContractVersionException(string message)
		: base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
	public UniffiContractChecksumException(string message)
		: base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
	where E : System.Exception
{
	E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
	public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

	public UniffiException Lift(RustBuffer error_buf)
	{
		RustBuffer.Free(error_buf);
		return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
	}
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
	public delegate void RustCallAction(ref UniffiRustCallStatus status);
	public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

	// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
	public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
		where E : UniffiException
	{
		var status = new UniffiRustCallStatus();
		var return_value = callback(ref status);
		if (status.IsSuccess())
		{
			return return_value;
		}
		else if (status.IsError())
		{
			throw errorHandler.Lift(status.error_buf);
		}
		else if (status.IsPanic())
		{
			// when the rust code sees a panic, it tries to construct a rustbuffer
			// with the message.  but if that code panics, then it just sends back
			// an empty buffer.
			if (status.error_buf.len > 0)
			{
				throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
			}
			else
			{
				throw new PanicException("Rust panic");
			}
		}
		else
		{
			throw new InternalException($"Unknown rust call status: {status.code}");
		}
	}

	// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
	public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
		where E : UniffiException
	{
		_UniffiHelpers.RustCallWithError(
			errorHandler,
			(ref UniffiRustCallStatus status) =>
			{
				callback(ref status);
				return 0;
			}
		);
	}

	// Call a rust function that returns a plain value
	public static U RustCall<U>(RustCallFunc<U> callback)
	{
		return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
	}

	// Call a rust function that returns a plain value
	public static void RustCall(RustCallAction callback)
	{
		_UniffiHelpers.RustCall(
			(ref UniffiRustCallStatus status) =>
			{
				callback(ref status);
				return 0;
			}
		);
	}
}

static class FFIObjectUtil
{
	public static void DisposeAll(params Object?[] list)
	{
		Dispose(list);
	}

	// Dispose is implemented by recursive type inspection at runtime. This is because
	// generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
	// is quite cumbersome.
	private static void Dispose(Object? obj)
	{
		if (obj == null)
		{
			return;
		}

		if (obj is IDisposable disposable)
		{
			disposable.Dispose();
			return;
		}

		var objType = obj.GetType();
		var typeCode = Type.GetTypeCode(objType);
		if (typeCode != TypeCode.Object)
		{
			return;
		}

		var genericArguments = objType.GetGenericArguments();
		if (genericArguments.Length == 0 && !objType.IsArray)
		{
			return;
		}

		if (obj is System.Collections.IDictionary objDictionary)
		{
			//This extra code tests to not call "Dispose" for a Dictionary<something, double>()
			//for all values as "double" and alike doesn't support interface "IDisposable"
			var valuesType = objType.GetGenericArguments()[1];
			var elementValuesTypeCode = Type.GetTypeCode(valuesType);
			if (elementValuesTypeCode != TypeCode.Object)
			{
				return;
			}
			foreach (var value in objDictionary.Values)
			{
				Dispose(value);
			}
		}
		else if (obj is System.Collections.IEnumerable listValues)
		{
			//This extra code tests to not call "Dispose" for a List<int>()
			//for all keys as "int" and alike doesn't support interface "IDisposable"
			var elementType = objType.IsArray ? objType.GetElementType() : genericArguments[0];
			var elementValuesTypeCode = Type.GetTypeCode(elementType);
			if (elementValuesTypeCode != TypeCode.Object)
			{
				return;
			}
			foreach (var value in listValues)
			{
				Dispose(value);
			}
		}
	}
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : System.Exception
{
	public StreamUnderflowException() { }
}

static class BigEndianStreamExtensions
{
	public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
	{
#if DOTNET_8_0_OR_GREATER
		Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
		byte[] buffer = new byte[bytesToWrite];
#endif
		var posByte = bytesToWrite;
		while (posByte != 0)
		{
			posByte--;
			buffer[posByte] = (byte)(value);
			value >>= 8;
		}

#if DOTNET_8_0_OR_GREATER
		stream.Write(buffer);
#else
		stream.Write(buffer, 0, buffer.Length);
#endif
	}

	public static void WriteInt64(this Stream stream, long value)
	{
		int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
		Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
		byte[] buffer = new byte[bytesToWrite];
#endif
		var posByte = bytesToWrite;
		while (posByte != 0)
		{
			posByte--;
			buffer[posByte] = (byte)(value);
			value >>= 8;
		}

#if DOTNET_8_0_OR_GREATER
		stream.Write(buffer);
#else
		stream.Write(buffer, 0, buffer.Length);
#endif
	}

	public static uint ReadUint32(this Stream stream, int bytesToRead = 4)
	{
		CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
		Span<byte> buffer = stackalloc byte[bytesToRead];
		stream.Read(buffer);
#else
		byte[] buffer = new byte[bytesToRead];
		stream.Read(buffer, 0, bytesToRead);
#endif
		uint result = 0;
		uint digitMultiplier = 1;
		int posByte = bytesToRead;
		while (posByte != 0)
		{
			posByte--;
			result |= buffer[posByte] * digitMultiplier;
			digitMultiplier <<= 8;
		}

		return result;
	}

	public static ulong ReadUInt64(this Stream stream)
	{
		int bytesToRead = 8;
		CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
		Span<byte> buffer = stackalloc byte[bytesToRead];
		stream.Read(buffer);
#else
		byte[] buffer = new byte[bytesToRead];
		stream.Read(buffer, 0, bytesToRead);
#endif
		ulong result = 0;
		ulong digitMultiplier = 1;
		int posByte = bytesToRead;
		while (posByte != 0)
		{
			posByte--;
			result |= buffer[posByte] * digitMultiplier;
			digitMultiplier <<= 8;
		}

		return result;
	}

	public static void CheckRemaining(this Stream stream, int length)
	{
		if (stream.Length - stream.Position < length)
		{
			throw new StreamUnderflowException();
		}
	}

	public static void ForEach<T>(this T[] items, Action<T> action)
	{
		foreach (var item in items)
		{
			action(item);
		}
	}
}

class BigEndianStream
{
	Stream stream;

	public BigEndianStream(Stream stream)
	{
		this.stream = stream;
	}

	public bool HasRemaining()
	{
		return (stream.Length - Position) > 0;
	}

	public long Position
	{
		get => stream.Position;
		set => stream.Position = value;
	}

	public void WriteBytes(byte[] buffer)
	{
#if DOTNET_8_0_OR_GREATER
		stream.Write(buffer);
#else
		stream.Write(buffer, 0, buffer.Length);
#endif
	}

	public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);

	public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

	public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);

	public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

	public void WriteUInt(uint value) => stream.WriteInt32((int)value);

	public void WriteInt(int value) => stream.WriteInt32(value);

	public void WriteULong(ulong value) => stream.WriteInt64((long)value);

	public void WriteLong(long value) => stream.WriteInt64(value);

	public void WriteFloat(float value)
	{
		unsafe
		{
			WriteInt(*((int*)&value));
		}
	}

	public void WriteDouble(double value) => stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

	public byte[] ReadBytes(int length)
	{
		stream.CheckRemaining(length);
		byte[] result = new byte[length];
		stream.Read(result, 0, length);
		return result;
	}

	public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);

	public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);

	public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);

	public ulong ReadULong() => stream.ReadUInt64();

	public sbyte ReadSByte() => (sbyte)ReadByte();

	public short ReadShort() => (short)ReadUShort();

	public int ReadInt() => (int)ReadUInt();

	public float ReadFloat()
	{
		unsafe
		{
			int value = ReadInt();
			return *((float*)&value);
		}
	}

	public long ReadLong() => (long)ReadULong();

	public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib
{
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiRustFutureContinuationCallback(ulong @data, sbyte @pollResult);

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureFree(ulong @handle);

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiCallbackInterfaceFree(ulong @handle);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFuture
	{
		public ulong @handle;
		public IntPtr @free;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructU8
	{
		public byte @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteU8(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU8 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructI8
	{
		public sbyte @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteI8(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI8 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructU16
	{
		public ushort @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteU16(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU16 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructI16
	{
		public short @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteI16(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI16 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructU32
	{
		public uint @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteU32(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU32 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructI32
	{
		public int @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteI32(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI32 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructU64
	{
		public ulong @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteU64(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU64 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructI64
	{
		public long @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteI64(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI64 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructF32
	{
		public float @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteF32(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructF32 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructF64
	{
		public double @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteF64(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructF64 @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructPointer
	{
		public IntPtr @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompletePointer(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructPointer @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructRustBuffer
	{
		public RustBuffer @returnValue;
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteRustBuffer(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructRustBuffer @result);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiForeignFutureStructVoid
	{
		public UniffiRustCallStatus @callStatus;
	}

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiForeignFutureCompleteVoid(ulong @callbackData, _UniFFILib.UniffiForeignFutureStructVoid @result);

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiCallbackInterfaceCancellationSourceMethod0(
		ulong @uniffiHandle,
		uint @id,
		IntPtr @uniffiOutReturn,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiCallbackInterfaceSyncUpdateMethod0(
		ulong @uniffiHandle,
		RustBuffer @data,
		IntPtr @uniffiOutReturn,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public delegate void UniffiCallbackInterfaceSyncUpdateMethod1(
		ulong @uniffiHandle,
		RustBuffer @transactions,
		IntPtr @uniffiOutReturn,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiVTableCallbackInterfaceCancellationSource
	{
		public IntPtr @setCancellationId;
		public IntPtr @uniffiFree;
	}

	[StructLayout(LayoutKind.Sequential)]
	public struct UniffiVTableCallbackInterfaceSyncUpdate
	{
		public IntPtr @updateStatus;
		public IntPtr @reportTransactions;
		public IntPtr @uniffiFree;
	}

	static _UniFFILib()
	{
		_UniFFILib.uniffiCheckContractApiVersion();
		_UniFFILib.uniffiCheckApiChecksums();

		UniffiCallbackInterfaceCancellationSource.Register();
		UniffiCallbackInterfaceSyncUpdate.Register();
	}

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void uniffi_nerdbank_zcash_rust_fn_init_callback_vtable_cancellationsource(
		ref _UniFFILib.UniffiVTableCallbackInterfaceCancellationSource @vtable
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void uniffi_nerdbank_zcash_rust_fn_init_callback_vtable_syncupdate(
		ref _UniFFILib.UniffiVTableCallbackInterfaceSyncUpdate @vtable
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_add_account(
		RustBuffer @config,
		RustBuffer @uri,
		RustBuffer @name,
		RustBuffer @seed,
		uint @accountIndex,
		RustBuffer @birthdayHeight,
		RustBuffer @cancellation,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_add_diversifier(
		RustBuffer @config,
		RustBuffer @accountId,
		RustBuffer @diversifierIndex,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void uniffi_nerdbank_zcash_rust_fn_func_cancel(uint @id, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern sbyte uniffi_nerdbank_zcash_rust_fn_func_disconnect_server(
		RustBuffer @uri,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_accounts(
		RustBuffer @config,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_birthday_height(
		RustBuffer @config,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_birthday_heights(
		RustBuffer @config,
		RustBuffer @accountId,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern uint uniffi_nerdbank_zcash_rust_fn_func_get_block_height(
		RustBuffer @uri,
		RustBuffer @cancellation,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_sync_height(
		RustBuffer @config,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_transactions(
		RustBuffer @config,
		RustBuffer @accountId,
		uint @startingBlock,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_unshielded_utxos(
		RustBuffer @config,
		RustBuffer @accountId,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_get_user_balances(
		RustBuffer @config,
		RustBuffer @accountId,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_import_account_ufvk(
		RustBuffer @config,
		RustBuffer @uri,
		RustBuffer @name,
		RustBuffer @ufvk,
		sbyte @spendingKeyAvailable,
		RustBuffer @birthdayHeight,
		RustBuffer @cancellation,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void uniffi_nerdbank_zcash_rust_fn_func_init(RustBuffer @config, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_send(
		RustBuffer @config,
		RustBuffer @uri,
		RustBuffer @usk,
		RustBuffer @sendDetails,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_shield(
		RustBuffer @config,
		RustBuffer @uri,
		RustBuffer @accountId,
		RustBuffer @usk,
		RustBuffer @address,
		ulong @shieldingThreshold,
		RustBuffer @memo,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_simulate_send(
		RustBuffer @config,
		RustBuffer @ufvk,
		RustBuffer @sendDetails,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer uniffi_nerdbank_zcash_rust_fn_func_sync(
		RustBuffer @config,
		RustBuffer @uri,
		RustBuffer @progress,
		sbyte @continually,
		RustBuffer @cancellation,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer ffi_nerdbank_zcash_rust_rustbuffer_alloc(ulong @size, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer ffi_nerdbank_zcash_rust_rustbuffer_from_bytes(
		ForeignBytes @bytes,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rustbuffer_free(RustBuffer @buf, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer ffi_nerdbank_zcash_rust_rustbuffer_reserve(
		RustBuffer @buf,
		ulong @additional,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_u8(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_u8(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_u8(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern byte ffi_nerdbank_zcash_rust_rust_future_complete_u8(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_i8(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_i8(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_i8(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern sbyte ffi_nerdbank_zcash_rust_rust_future_complete_i8(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_u16(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_u16(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_u16(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort ffi_nerdbank_zcash_rust_rust_future_complete_u16(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_i16(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_i16(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_i16(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern short ffi_nerdbank_zcash_rust_rust_future_complete_i16(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_u32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_u32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_u32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern uint ffi_nerdbank_zcash_rust_rust_future_complete_u32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_i32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_i32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_i32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern int ffi_nerdbank_zcash_rust_rust_future_complete_i32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_u64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_u64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_u64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ulong ffi_nerdbank_zcash_rust_rust_future_complete_u64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_i64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_i64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_i64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern long ffi_nerdbank_zcash_rust_rust_future_complete_i64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_f32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_f32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_f32(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern float ffi_nerdbank_zcash_rust_rust_future_complete_f32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_f64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_f64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_f64(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern double ffi_nerdbank_zcash_rust_rust_future_complete_f64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_pointer(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_pointer(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_pointer(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern IntPtr ffi_nerdbank_zcash_rust_rust_future_complete_pointer(
		IntPtr @handle,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_rust_buffer(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_rust_buffer(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_rust_buffer(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern RustBuffer ffi_nerdbank_zcash_rust_rust_future_complete_rust_buffer(
		IntPtr @handle,
		ref UniffiRustCallStatus _uniffi_out_err
	);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_poll_void(IntPtr @handle, IntPtr @callback, IntPtr @callbackData);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_cancel_void(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_free_void(IntPtr @handle);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern void ffi_nerdbank_zcash_rust_rust_future_complete_void(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err);

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_add_account();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_add_diversifier();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_cancel();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_disconnect_server();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_accounts();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_height();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_heights();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_block_height();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_sync_height();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_transactions();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_unshielded_utxos();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_get_user_balances();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_import_account_ufvk();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_init();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_send();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_shield();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_simulate_send();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_func_sync();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_method_cancellationsource_set_cancellation_id();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_update_status();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern ushort uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_report_transactions();

	[DllImport("@rpath/nerdbank_zcash_rust.framework/nerdbank_zcash_rust", CallingConvention = CallingConvention.Cdecl)]
	public static extern uint ffi_nerdbank_zcash_rust_uniffi_contract_version();

	static void uniffiCheckContractApiVersion()
	{
		var scaffolding_contract_version = _UniFFILib.ffi_nerdbank_zcash_rust_uniffi_contract_version();
		if (29 != scaffolding_contract_version)
		{
			throw new UniffiContractVersionException(
				$"uniffi.LightWallet: uniffi bindings expected version `29`, library returned `{scaffolding_contract_version}`"
			);
		}
	}

	static void uniffiCheckApiChecksums()
	{
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_add_account();
			if (checksum != 30842)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_add_account` checksum `30842`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_add_diversifier();
			if (checksum != 29202)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_add_diversifier` checksum `29202`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_cancel();
			if (checksum != 41545)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_cancel` checksum `41545`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_disconnect_server();
			if (checksum != 22144)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_disconnect_server` checksum `22144`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_accounts();
			if (checksum != 12650)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_accounts` checksum `12650`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_height();
			if (checksum != 25579)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_height` checksum `25579`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_heights();
			if (checksum != 43688)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_birthday_heights` checksum `43688`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_block_height();
			if (checksum != 23405)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_block_height` checksum `23405`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_sync_height();
			if (checksum != 394)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_sync_height` checksum `394`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_transactions();
			if (checksum != 60643)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_transactions` checksum `60643`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_unshielded_utxos();
			if (checksum != 27236)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_unshielded_utxos` checksum `27236`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_get_user_balances();
			if (checksum != 25249)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_get_user_balances` checksum `25249`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_import_account_ufvk();
			if (checksum != 32453)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_import_account_ufvk` checksum `32453`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_init();
			if (checksum != 24220)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_init` checksum `24220`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_send();
			if (checksum != 4470)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_send` checksum `4470`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_shield();
			if (checksum != 44803)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_shield` checksum `44803`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_simulate_send();
			if (checksum != 46308)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_simulate_send` checksum `46308`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_func_sync();
			if (checksum != 57942)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_func_sync` checksum `57942`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_method_cancellationsource_set_cancellation_id();
			if (checksum != 25003)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_method_cancellationsource_set_cancellation_id` checksum `25003`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_update_status();
			if (checksum != 63625)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_update_status` checksum `63625`, library returned `{checksum}`"
				);
			}
		}
		{
			var checksum = _UniFFILib.uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_report_transactions();
			if (checksum != 55055)
			{
				throw new UniffiContractChecksumException(
					$"uniffi.LightWallet: uniffi bindings expected function `uniffi_nerdbank_zcash_rust_checksum_method_syncupdate_report_transactions` checksum `55055`, library returned `{checksum}`"
				);
			}
		}
	}
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt32 : FfiConverter<uint, uint>
{
	public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

	public override uint Lift(uint value)
	{
		return value;
	}

	public override uint Read(BigEndianStream stream)
	{
		return stream.ReadUInt();
	}

	public override uint Lower(uint value)
	{
		return value;
	}

	public override int AllocationSize(uint value)
	{
		return 4;
	}

	public override void Write(uint value, BigEndianStream stream)
	{
		stream.WriteUInt(value);
	}
}

class FfiConverterUInt64 : FfiConverter<ulong, ulong>
{
	public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

	public override ulong Lift(ulong value)
	{
		return value;
	}

	public override ulong Read(BigEndianStream stream)
	{
		return stream.ReadULong();
	}

	public override ulong Lower(ulong value)
	{
		return value;
	}

	public override int AllocationSize(ulong value)
	{
		return 8;
	}

	public override void Write(ulong value, BigEndianStream stream)
	{
		stream.WriteULong(value);
	}
}

class FfiConverterInt64 : FfiConverter<long, long>
{
	public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

	public override long Lift(long value)
	{
		return value;
	}

	public override long Read(BigEndianStream stream)
	{
		return stream.ReadLong();
	}

	public override long Lower(long value)
	{
		return value;
	}

	public override int AllocationSize(long value)
	{
		return 8;
	}

	public override void Write(long value, BigEndianStream stream)
	{
		stream.WriteLong(value);
	}
}

class FfiConverterBoolean : FfiConverter<bool, sbyte>
{
	public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

	public override bool Lift(sbyte value)
	{
		return value != 0;
	}

	public override bool Read(BigEndianStream stream)
	{
		return Lift(stream.ReadSByte());
	}

	public override sbyte Lower(bool value)
	{
		return value ? (sbyte)1 : (sbyte)0;
	}

	public override int AllocationSize(bool value)
	{
		return (sbyte)1;
	}

	public override void Write(bool value, BigEndianStream stream)
	{
		stream.WriteSByte(Lower(value));
	}
}

class FfiConverterString : FfiConverter<string, RustBuffer>
{
	public static FfiConverterString INSTANCE = new FfiConverterString();

	// Note: we don't inherit from FfiConverterRustBuffer, because we use a
	// special encoding when lowering/lifting.  We can use `RustBuffer.len` to
	// store our length and avoid writing it out to the buffer.
	public override string Lift(RustBuffer value)
	{
		try
		{
			var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
			return System.Text.Encoding.UTF8.GetString(bytes);
		}
		finally
		{
			RustBuffer.Free(value);
		}
	}

	public override string Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		var bytes = stream.ReadBytes(length);
		return System.Text.Encoding.UTF8.GetString(bytes);
	}

	public override RustBuffer Lower(string value)
	{
		var bytes = System.Text.Encoding.UTF8.GetBytes(value);
		var rbuf = RustBuffer.Alloc(bytes.Length);
		rbuf.AsWriteableStream().WriteBytes(bytes);
		return rbuf;
	}

	// TODO(CS)
	// We aren't sure exactly how many bytes our string will be once it's UTF-8
	// encoded.  Allocate 3 bytes per unicode codepoint which will always be
	// enough.
	public override int AllocationSize(string value)
	{
		const int sizeForLength = 4;
		var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
		return sizeForLength + sizeForString;
	}

	public override void Write(string value, BigEndianStream stream)
	{
		var bytes = System.Text.Encoding.UTF8.GetBytes(value);
		stream.WriteInt(bytes.Length);
		stream.WriteBytes(bytes);
	}
}

class FfiConverterByteArray : FfiConverterRustBuffer<byte[]>
{
	public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

	public override byte[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		return stream.ReadBytes(length);
	}

	public override int AllocationSize(byte[] value)
	{
		return 4 + value.Length;
	}

	public override void Write(byte[] value, BigEndianStream stream)
	{
		stream.WriteInt(value.Length);
		stream.WriteBytes(value);
	}
}

class FfiConverterTimestamp : FfiConverterRustBuffer<DateTime>
{
	public static FfiConverterTimestamp INSTANCE = new FfiConverterTimestamp();

	// https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/TimeSpan.cs
	private const uint NanosecondsPerTick = 100;

	// DateTime.UnixEpoch is not available in net48
	private static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

	public override DateTime Read(BigEndianStream stream)
	{
		var seconds = stream.ReadLong();
		var nanoseconds = stream.ReadUInt();
		var sign = 1;
		if (seconds < 0)
		{
			sign = -1;
		}
		var ticks = seconds * TimeSpan.TicksPerSecond;
		ticks += (nanoseconds / NanosecondsPerTick) * sign;
		return UnixEpoch.AddTicks(ticks);
	}

	public override int AllocationSize(DateTime value)
	{
		// 8 bytes for seconds, 4 bytes for nanoseconds
		return 12;
	}

	public override void Write(DateTime value, BigEndianStream stream)
	{
		var epochOffset = value.Subtract(UnixEpoch);

		int sign = 1;
		if (epochOffset.Ticks < 0)
		{
			epochOffset = epochOffset.Negate();
			sign = -1;
		}

		stream.WriteLong(epochOffset.Ticks / TimeSpan.TicksPerSecond * sign);
		stream.WriteUInt(Convert.ToUInt32(epochOffset.Ticks % TimeSpan.TicksPerSecond * NanosecondsPerTick));
	}
}

/// <param name="id">
/// A 16-byte buffer storing a GUID.
/// </param>
/// <param name="uvk">
/// The string encoding of the Unified Viewing Key associated with this account.
/// </param>
/// <param name="birthday_heights">
/// The various birthday heights associated with this account.
/// </param>
internal record AccountInfo(
	/// <summary>
	/// A 16-byte buffer storing a GUID.
	/// </summary>
	byte[] @id,
	/// <summary>
	/// The string encoding of the Unified Viewing Key associated with this account.
	/// </summary>
	string? @uvk,
	/// <summary>
	/// The various birthday heights associated with this account.
	/// </summary>
	BirthdayHeights @birthdayHeights
) { }

class FfiConverterTypeAccountInfo : FfiConverterRustBuffer<AccountInfo>
{
	public static FfiConverterTypeAccountInfo INSTANCE = new FfiConverterTypeAccountInfo();

	public override AccountInfo Read(BigEndianStream stream)
	{
		return new AccountInfo(
			@id: FfiConverterByteArray.INSTANCE.Read(stream),
			@uvk: FfiConverterOptionalString.INSTANCE.Read(stream),
			@birthdayHeights: FfiConverterTypeBirthdayHeights.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(AccountInfo value)
	{
		return 0
			+ FfiConverterByteArray.INSTANCE.AllocationSize(value.@id)
			+ FfiConverterOptionalString.INSTANCE.AllocationSize(value.@uvk)
			+ FfiConverterTypeBirthdayHeights.INSTANCE.AllocationSize(value.@birthdayHeights);
	}

	public override void Write(AccountInfo value, BigEndianStream stream)
	{
		FfiConverterByteArray.INSTANCE.Write(value.@id, stream);
		FfiConverterOptionalString.INSTANCE.Write(value.@uvk, stream);
		FfiConverterTypeBirthdayHeights.INSTANCE.Write(value.@birthdayHeights, stream);
	}
}

internal record BirthdayHeights(uint @originalBirthdayHeight, uint? @birthdayHeight, uint? @rebirthHeight) { }

class FfiConverterTypeBirthdayHeights : FfiConverterRustBuffer<BirthdayHeights>
{
	public static FfiConverterTypeBirthdayHeights INSTANCE = new FfiConverterTypeBirthdayHeights();

	public override BirthdayHeights Read(BigEndianStream stream)
	{
		return new BirthdayHeights(
			@originalBirthdayHeight: FfiConverterUInt32.INSTANCE.Read(stream),
			@birthdayHeight: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
			@rebirthHeight: FfiConverterOptionalUInt32.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(BirthdayHeights value)
	{
		return 0
			+ FfiConverterUInt32.INSTANCE.AllocationSize(value.@originalBirthdayHeight)
			+ FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@birthdayHeight)
			+ FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@rebirthHeight);
	}

	public override void Write(BirthdayHeights value, BigEndianStream stream)
	{
		FfiConverterUInt32.INSTANCE.Write(value.@originalBirthdayHeight, stream);
		FfiConverterOptionalUInt32.INSTANCE.Write(value.@birthdayHeight, stream);
		FfiConverterOptionalUInt32.INSTANCE.Write(value.@rebirthHeight, stream);
	}
}

internal record DbInit(string @dataFile, ChainType @network) { }

class FfiConverterTypeDbInit : FfiConverterRustBuffer<DbInit>
{
	public static FfiConverterTypeDbInit INSTANCE = new FfiConverterTypeDbInit();

	public override DbInit Read(BigEndianStream stream)
	{
		return new DbInit(@dataFile: FfiConverterString.INSTANCE.Read(stream), @network: FfiConverterTypeChainType.INSTANCE.Read(stream));
	}

	public override int AllocationSize(DbInit value)
	{
		return 0
			+ FfiConverterString.INSTANCE.AllocationSize(value.@dataFile)
			+ FfiConverterTypeChainType.INSTANCE.AllocationSize(value.@network);
	}

	public override void Write(DbInit value, BigEndianStream stream)
	{
		FfiConverterString.INSTANCE.Write(value.@dataFile, stream);
		FfiConverterTypeChainType.INSTANCE.Write(value.@network, stream);
	}
}

internal record SendDetails(ulong @fee) { }

class FfiConverterTypeSendDetails : FfiConverterRustBuffer<SendDetails>
{
	public static FfiConverterTypeSendDetails INSTANCE = new FfiConverterTypeSendDetails();

	public override SendDetails Read(BigEndianStream stream)
	{
		return new SendDetails(@fee: FfiConverterUInt64.INSTANCE.Read(stream));
	}

	public override int AllocationSize(SendDetails value)
	{
		return 0 + FfiConverterUInt64.INSTANCE.AllocationSize(value.@fee);
	}

	public override void Write(SendDetails value, BigEndianStream stream)
	{
		FfiConverterUInt64.INSTANCE.Write(value.@fee, stream);
	}
}

internal record SendTransactionResult(byte[] @txid) { }

class FfiConverterTypeSendTransactionResult : FfiConverterRustBuffer<SendTransactionResult>
{
	public static FfiConverterTypeSendTransactionResult INSTANCE = new FfiConverterTypeSendTransactionResult();

	public override SendTransactionResult Read(BigEndianStream stream)
	{
		return new SendTransactionResult(@txid: FfiConverterByteArray.INSTANCE.Read(stream));
	}

	public override int AllocationSize(SendTransactionResult value)
	{
		return 0 + FfiConverterByteArray.INSTANCE.AllocationSize(value.@txid);
	}

	public override void Write(SendTransactionResult value, BigEndianStream stream)
	{
		FfiConverterByteArray.INSTANCE.Write(value.@txid, stream);
	}
}

internal record SyncUpdateData(uint? @lastFullyScannedBlock, uint @tipHeight, ulong @currentStep, ulong @totalSteps, string? @lastError) { }

class FfiConverterTypeSyncUpdateData : FfiConverterRustBuffer<SyncUpdateData>
{
	public static FfiConverterTypeSyncUpdateData INSTANCE = new FfiConverterTypeSyncUpdateData();

	public override SyncUpdateData Read(BigEndianStream stream)
	{
		return new SyncUpdateData(
			@lastFullyScannedBlock: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
			@tipHeight: FfiConverterUInt32.INSTANCE.Read(stream),
			@currentStep: FfiConverterUInt64.INSTANCE.Read(stream),
			@totalSteps: FfiConverterUInt64.INSTANCE.Read(stream),
			@lastError: FfiConverterOptionalString.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(SyncUpdateData value)
	{
		return 0
			+ FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@lastFullyScannedBlock)
			+ FfiConverterUInt32.INSTANCE.AllocationSize(value.@tipHeight)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@currentStep)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@totalSteps)
			+ FfiConverterOptionalString.INSTANCE.AllocationSize(value.@lastError);
	}

	public override void Write(SyncUpdateData value, BigEndianStream stream)
	{
		FfiConverterOptionalUInt32.INSTANCE.Write(value.@lastFullyScannedBlock, stream);
		FfiConverterUInt32.INSTANCE.Write(value.@tipHeight, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@currentStep, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@totalSteps, stream);
		FfiConverterOptionalString.INSTANCE.Write(value.@lastError, stream);
	}
}

/// <param name="account_id">
/// A 16-byte buffer storing a GUID.
/// </param>
/// <param name="txid">
/// The transaction ID.
/// </param>
/// <param name="block_time">
/// The timestamp the block containing the transaction was mined, if applicable.
/// </param>
/// <param name="mined_height">
/// The height of the block containing the transaction, if mined.
/// </param>
/// <param name="expired_unmined">
/// A value indicating whether the transaction expired without being mined.
/// </param>
/// <param name="account_balance_delta">
/// The net impact this transaction has (or would have) on the account balance.
/// </param>
/// <param name="fee">
/// The network fee associated with this transaction.
/// </param>
/// <param name="outgoing">
/// The notes associated with withdrawals from this account.
/// </param>
/// <param name="incoming">
/// The notes associated with deposits into this account.
/// </param>
/// <param name="change">
/// The note(s) used to create change for this transaction.
/// </param>
internal record Transaction(
	/// <summary>
	/// A 16-byte buffer storing a GUID.
	/// </summary>
	byte[] @accountId,
	/// <summary>
	/// The transaction ID.
	/// </summary>
	byte[] @txid,
	/// <summary>
	/// The timestamp the block containing the transaction was mined, if applicable.
	/// </summary>
	DateTime? @blockTime,
	/// <summary>
	/// The height of the block containing the transaction, if mined.
	/// </summary>
	uint? @minedHeight,
	/// <summary>
	/// A value indicating whether the transaction expired without being mined.
	/// </summary>
	bool @expiredUnmined,
	/// <summary>
	/// The net impact this transaction has (or would have) on the account balance.
	/// </summary>
	long @accountBalanceDelta,
	/// <summary>
	/// The network fee associated with this transaction.
	/// </summary>
	ulong? @fee,
	/// <summary>
	/// The notes associated with withdrawals from this account.
	/// </summary>
	TransactionNote[] @outgoing,
	/// <summary>
	/// The notes associated with deposits into this account.
	/// </summary>
	TransactionNote[] @incoming,
	/// <summary>
	/// The note(s) used to create change for this transaction.
	/// </summary>
	TransactionNote[] @change
) { }

class FfiConverterTypeTransaction : FfiConverterRustBuffer<Transaction>
{
	public static FfiConverterTypeTransaction INSTANCE = new FfiConverterTypeTransaction();

	public override Transaction Read(BigEndianStream stream)
	{
		return new Transaction(
			@accountId: FfiConverterByteArray.INSTANCE.Read(stream),
			@txid: FfiConverterByteArray.INSTANCE.Read(stream),
			@blockTime: FfiConverterOptionalTimestamp.INSTANCE.Read(stream),
			@minedHeight: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
			@expiredUnmined: FfiConverterBoolean.INSTANCE.Read(stream),
			@accountBalanceDelta: FfiConverterInt64.INSTANCE.Read(stream),
			@fee: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
			@outgoing: FfiConverterSequenceTypeTransactionNote.INSTANCE.Read(stream),
			@incoming: FfiConverterSequenceTypeTransactionNote.INSTANCE.Read(stream),
			@change: FfiConverterSequenceTypeTransactionNote.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(Transaction value)
	{
		return 0
			+ FfiConverterByteArray.INSTANCE.AllocationSize(value.@accountId)
			+ FfiConverterByteArray.INSTANCE.AllocationSize(value.@txid)
			+ FfiConverterOptionalTimestamp.INSTANCE.AllocationSize(value.@blockTime)
			+ FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@minedHeight)
			+ FfiConverterBoolean.INSTANCE.AllocationSize(value.@expiredUnmined)
			+ FfiConverterInt64.INSTANCE.AllocationSize(value.@accountBalanceDelta)
			+ FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@fee)
			+ FfiConverterSequenceTypeTransactionNote.INSTANCE.AllocationSize(value.@outgoing)
			+ FfiConverterSequenceTypeTransactionNote.INSTANCE.AllocationSize(value.@incoming)
			+ FfiConverterSequenceTypeTransactionNote.INSTANCE.AllocationSize(value.@change);
	}

	public override void Write(Transaction value, BigEndianStream stream)
	{
		FfiConverterByteArray.INSTANCE.Write(value.@accountId, stream);
		FfiConverterByteArray.INSTANCE.Write(value.@txid, stream);
		FfiConverterOptionalTimestamp.INSTANCE.Write(value.@blockTime, stream);
		FfiConverterOptionalUInt32.INSTANCE.Write(value.@minedHeight, stream);
		FfiConverterBoolean.INSTANCE.Write(value.@expiredUnmined, stream);
		FfiConverterInt64.INSTANCE.Write(value.@accountBalanceDelta, stream);
		FfiConverterOptionalUInt64.INSTANCE.Write(value.@fee, stream);
		FfiConverterSequenceTypeTransactionNote.INSTANCE.Write(value.@outgoing, stream);
		FfiConverterSequenceTypeTransactionNote.INSTANCE.Write(value.@incoming, stream);
		FfiConverterSequenceTypeTransactionNote.INSTANCE.Write(value.@change, stream);
	}
}

internal record TransactionNote(ulong @value, byte[]? @memo, string @recipient, Pool @pool) { }

class FfiConverterTypeTransactionNote : FfiConverterRustBuffer<TransactionNote>
{
	public static FfiConverterTypeTransactionNote INSTANCE = new FfiConverterTypeTransactionNote();

	public override TransactionNote Read(BigEndianStream stream)
	{
		return new TransactionNote(
			@value: FfiConverterUInt64.INSTANCE.Read(stream),
			@memo: FfiConverterOptionalByteArray.INSTANCE.Read(stream),
			@recipient: FfiConverterString.INSTANCE.Read(stream),
			@pool: FfiConverterTypePool.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(TransactionNote value)
	{
		return 0
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@value)
			+ FfiConverterOptionalByteArray.INSTANCE.AllocationSize(value.@memo)
			+ FfiConverterString.INSTANCE.AllocationSize(value.@recipient)
			+ FfiConverterTypePool.INSTANCE.AllocationSize(value.@pool);
	}

	public override void Write(TransactionNote value, BigEndianStream stream)
	{
		FfiConverterUInt64.INSTANCE.Write(value.@value, stream);
		FfiConverterOptionalByteArray.INSTANCE.Write(value.@memo, stream);
		FfiConverterString.INSTANCE.Write(value.@recipient, stream);
		FfiConverterTypePool.INSTANCE.Write(value.@pool, stream);
	}
}

internal record TransactionSendDetail(ulong @value, byte[]? @memo, string @recipient) { }

class FfiConverterTypeTransactionSendDetail : FfiConverterRustBuffer<TransactionSendDetail>
{
	public static FfiConverterTypeTransactionSendDetail INSTANCE = new FfiConverterTypeTransactionSendDetail();

	public override TransactionSendDetail Read(BigEndianStream stream)
	{
		return new TransactionSendDetail(
			@value: FfiConverterUInt64.INSTANCE.Read(stream),
			@memo: FfiConverterOptionalByteArray.INSTANCE.Read(stream),
			@recipient: FfiConverterString.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(TransactionSendDetail value)
	{
		return 0
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@value)
			+ FfiConverterOptionalByteArray.INSTANCE.AllocationSize(value.@memo)
			+ FfiConverterString.INSTANCE.AllocationSize(value.@recipient);
	}

	public override void Write(TransactionSendDetail value, BigEndianStream stream)
	{
		FfiConverterUInt64.INSTANCE.Write(value.@value, stream);
		FfiConverterOptionalByteArray.INSTANCE.Write(value.@memo, stream);
		FfiConverterString.INSTANCE.Write(value.@recipient, stream);
	}
}

internal record TransparentNote(ulong @value, string @recipient) { }

class FfiConverterTypeTransparentNote : FfiConverterRustBuffer<TransparentNote>
{
	public static FfiConverterTypeTransparentNote INSTANCE = new FfiConverterTypeTransparentNote();

	public override TransparentNote Read(BigEndianStream stream)
	{
		return new TransparentNote(@value: FfiConverterUInt64.INSTANCE.Read(stream), @recipient: FfiConverterString.INSTANCE.Read(stream));
	}

	public override int AllocationSize(TransparentNote value)
	{
		return 0 + FfiConverterUInt64.INSTANCE.AllocationSize(value.@value) + FfiConverterString.INSTANCE.AllocationSize(value.@recipient);
	}

	public override void Write(TransparentNote value, BigEndianStream stream)
	{
		FfiConverterUInt64.INSTANCE.Write(value.@value, stream);
		FfiConverterString.INSTANCE.Write(value.@recipient, stream);
	}
}

internal record UserBalances(
	ulong @spendable,
	ulong @immatureChange,
	ulong @minimumFees,
	ulong @immatureIncome,
	ulong @dust,
	ulong @incoming,
	ulong @incomingDust
) { }

class FfiConverterTypeUserBalances : FfiConverterRustBuffer<UserBalances>
{
	public static FfiConverterTypeUserBalances INSTANCE = new FfiConverterTypeUserBalances();

	public override UserBalances Read(BigEndianStream stream)
	{
		return new UserBalances(
			@spendable: FfiConverterUInt64.INSTANCE.Read(stream),
			@immatureChange: FfiConverterUInt64.INSTANCE.Read(stream),
			@minimumFees: FfiConverterUInt64.INSTANCE.Read(stream),
			@immatureIncome: FfiConverterUInt64.INSTANCE.Read(stream),
			@dust: FfiConverterUInt64.INSTANCE.Read(stream),
			@incoming: FfiConverterUInt64.INSTANCE.Read(stream),
			@incomingDust: FfiConverterUInt64.INSTANCE.Read(stream)
		);
	}

	public override int AllocationSize(UserBalances value)
	{
		return 0
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@spendable)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@immatureChange)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@minimumFees)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@immatureIncome)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@dust)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@incoming)
			+ FfiConverterUInt64.INSTANCE.AllocationSize(value.@incomingDust);
	}

	public override void Write(UserBalances value, BigEndianStream stream)
	{
		FfiConverterUInt64.INSTANCE.Write(value.@spendable, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@immatureChange, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@minimumFees, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@immatureIncome, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@dust, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@incoming, stream);
		FfiConverterUInt64.INSTANCE.Write(value.@incomingDust, stream);
	}
}

internal enum ChainType : int
{
	Testnet,
	Mainnet,
}

class FfiConverterTypeChainType : FfiConverterRustBuffer<ChainType>
{
	public static FfiConverterTypeChainType INSTANCE = new FfiConverterTypeChainType();

	public override ChainType Read(BigEndianStream stream)
	{
		var value = stream.ReadInt() - 1;
		if (Enum.IsDefined(typeof(ChainType), value))
		{
			return (ChainType)value;
		}
		else
		{
			throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeChainType.Read()", value));
		}
	}

	public override int AllocationSize(ChainType value)
	{
		return 4;
	}

	public override void Write(ChainType value, BigEndianStream stream)
	{
		stream.WriteInt((int)value + 1);
	}
}

internal class LightWalletException : UniffiException
{
	LightWalletException()
		: base() { }

	LightWalletException(String @Message)
		: base(@Message) { }

	// Each variant is a nested class


	public class InvalidArgument : LightWalletException
	{
		// Members
		public string @message;

		// Constructor
		public InvalidArgument(string @message)
			: base("@message" + "=" + @message)
		{
			this.@message = @message;
		}
	}

	public class InvalidUri : LightWalletException
	{
		public InvalidUri()
			: base() { }
	}

	public class SqliteClientException : LightWalletException
	{
		// Members
		public string @message;

		// Constructor
		public SqliteClientException(string @message)
			: base("@message" + "=" + @message)
		{
			this.@message = @message;
		}
	}

	public class Canceled : LightWalletException
	{
		public Canceled()
			: base() { }
	}

	public class SyncFirst : LightWalletException
	{
		public SyncFirst()
			: base() { }
	}

	public class InsufficientFunds : LightWalletException
	{
		// Members
		public ulong @required;
		public ulong @available;

		// Constructor
		public InsufficientFunds(ulong @required, ulong @available)
			: base("@required" + "=" + @required + ", " + "@available" + "=" + @available)
		{
			this.@required = @required;

			this.@available = @available;
		}
	}

	public class Other : LightWalletException
	{
		// Members
		public string @message;

		// Constructor
		public Other(string @message)
			: base("@message" + "=" + @message)
		{
			this.@message = @message;
		}
	}
}

class FfiConverterTypeLightWalletError : FfiConverterRustBuffer<LightWalletException>, CallStatusErrorHandler<LightWalletException>
{
	public static FfiConverterTypeLightWalletError INSTANCE = new FfiConverterTypeLightWalletError();

	public override LightWalletException Read(BigEndianStream stream)
	{
		var value = stream.ReadInt();
		switch (value)
		{
			case 1:
				return new LightWalletException.InvalidArgument(FfiConverterString.INSTANCE.Read(stream));
			case 2:
				return new LightWalletException.InvalidUri();
			case 3:
				return new LightWalletException.SqliteClientException(FfiConverterString.INSTANCE.Read(stream));
			case 4:
				return new LightWalletException.Canceled();
			case 5:
				return new LightWalletException.SyncFirst();
			case 6:
				return new LightWalletException.InsufficientFunds(
					FfiConverterUInt64.INSTANCE.Read(stream),
					FfiConverterUInt64.INSTANCE.Read(stream)
				);
			case 7:
				return new LightWalletException.Other(FfiConverterString.INSTANCE.Read(stream));
			default:
				throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeLightWalletError.Read()", value));
		}
	}

	public override int AllocationSize(LightWalletException value)
	{
		switch (value)
		{
			case LightWalletException.InvalidArgument variant_value:
				return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

			case LightWalletException.InvalidUri variant_value:
				return 4;

			case LightWalletException.SqliteClientException variant_value:
				return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);

			case LightWalletException.Canceled variant_value:
				return 4;

			case LightWalletException.SyncFirst variant_value:
				return 4;

			case LightWalletException.InsufficientFunds variant_value:
				return 4
					+ FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@required)
					+ FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@available);

			case LightWalletException.Other variant_value:
				return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
			default:
				throw new InternalException(
					String.Format("invalid error value '{0}' in FfiConverterTypeLightWalletError.AllocationSize()", value)
				);
		}
	}

	public override void Write(LightWalletException value, BigEndianStream stream)
	{
		switch (value)
		{
			case LightWalletException.InvalidArgument variant_value:
				stream.WriteInt(1);
				FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
				break;
			case LightWalletException.InvalidUri variant_value:
				stream.WriteInt(2);
				break;
			case LightWalletException.SqliteClientException variant_value:
				stream.WriteInt(3);
				FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
				break;
			case LightWalletException.Canceled variant_value:
				stream.WriteInt(4);
				break;
			case LightWalletException.SyncFirst variant_value:
				stream.WriteInt(5);
				break;
			case LightWalletException.InsufficientFunds variant_value:
				stream.WriteInt(6);
				FfiConverterUInt64.INSTANCE.Write(variant_value.@required, stream);
				FfiConverterUInt64.INSTANCE.Write(variant_value.@available, stream);
				break;
			case LightWalletException.Other variant_value:
				stream.WriteInt(7);
				FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
				break;
			default:
				throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeLightWalletError.Write()", value));
		}
	}
}

internal enum Pool : int
{
	Transparent,
	Sapling,
	Orchard,
}

class FfiConverterTypePool : FfiConverterRustBuffer<Pool>
{
	public static FfiConverterTypePool INSTANCE = new FfiConverterTypePool();

	public override Pool Read(BigEndianStream stream)
	{
		var value = stream.ReadInt() - 1;
		if (Enum.IsDefined(typeof(Pool), value))
		{
			return (Pool)value;
		}
		else
		{
			throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePool.Read()", value));
		}
	}

	public override int AllocationSize(Pool value)
	{
		return 4;
	}

	public override void Write(Pool value, BigEndianStream stream)
	{
		stream.WriteInt((int)value + 1);
	}
}

internal interface CancellationSource
{
	void SetCancellationId(uint @id);
}

class UniffiCallbackInterfaceCancellationSource
{
	static void SetCancellationId(ulong @uniffiHandle, uint @id, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
	{
		var handle = @uniffiHandle;
		if (FfiConverterTypeCancellationSource.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
		{
			uniffiObject.SetCancellationId(FfiConverterUInt32.INSTANCE.Lift(@id));
		}
		else
		{
			throw new InternalException($"No callback in handlemap '{handle}'");
		}
	}

	static void UniffiFree(ulong @handle)
	{
		FfiConverterTypeCancellationSource.INSTANCE.handleMap.Remove(@handle);
	}

	static _UniFFILib.UniffiCallbackInterfaceCancellationSourceMethod0 _m0 =
		new _UniFFILib.UniffiCallbackInterfaceCancellationSourceMethod0(SetCancellationId);
	static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

	public static _UniFFILib.UniffiVTableCallbackInterfaceCancellationSource _vtable =
		new _UniFFILib.UniffiVTableCallbackInterfaceCancellationSource
		{
			@setCancellationId = Marshal.GetFunctionPointerForDelegate(_m0),
			@uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
		};

	public static void Register()
	{
		_UniFFILib.uniffi_nerdbank_zcash_rust_fn_init_callback_vtable_cancellationsource(
			ref UniffiCallbackInterfaceCancellationSource._vtable
		);
	}
}

class ConcurrentHandleMap<T>
	where T : notnull
{
	Dictionary<ulong, T> map = new Dictionary<ulong, T>();

	Object lock_ = new Object();
	ulong currentHandle = 0;

	public ulong Insert(T obj)
	{
		lock (lock_)
		{
			currentHandle += 1;
			map[currentHandle] = obj;
			return currentHandle;
		}
	}

	public bool TryGet(ulong handle, out T result)
	{
		lock (lock_)
		{
#pragma warning disable 8601 // Possible null reference assignment
			return map.TryGetValue(handle, out result);
#pragma warning restore 8601
		}
	}

	public T Get(ulong handle)
	{
		if (TryGet(handle, out var result))
		{
			return result;
		}
		else
		{
			throw new InternalException("ConcurrentHandleMap: Invalid handle");
		}
	}

	public bool Remove(ulong handle)
	{
		return Remove(handle, out T result);
	}

	public bool Remove(ulong handle, out T result)
	{
		lock (lock_)
		{
			// Possible null reference assignment
#pragma warning disable 8601
			if (map.TryGetValue(handle, out result))
			{
#pragma warning restore 8601
				map.Remove(handle);
				return true;
			}
			else
			{
				return false;
			}
		}
	}
}

static class UniffiCallbackResponseStatus
{
	public static sbyte SUCCESS = 0;
	public static sbyte ERROR = 1;
	public static sbyte UNEXPECTED_ERROR = 2;
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeCancellationSource : FfiConverter<CancellationSource, ulong>
{
	public static FfiConverterTypeCancellationSource INSTANCE = new FfiConverterTypeCancellationSource();

	public ConcurrentHandleMap<CancellationSource> handleMap = new ConcurrentHandleMap<CancellationSource>();

	public override ulong Lower(CancellationSource value)
	{
		return handleMap.Insert(value);
	}

	public override CancellationSource Lift(ulong value)
	{
		if (handleMap.TryGet(value, out var uniffiCallback))
		{
			return uniffiCallback;
		}
		else
		{
			throw new InternalException($"No callback in handlemap '{value}'");
		}
	}

	public override CancellationSource Read(BigEndianStream stream)
	{
		return Lift(stream.ReadULong());
	}

	public override int AllocationSize(CancellationSource value)
	{
		return 8;
	}

	public override void Write(CancellationSource value, BigEndianStream stream)
	{
		stream.WriteULong(Lower(value));
	}
}

internal interface SyncUpdate
{
	void UpdateStatus(SyncUpdateData @data);
	void ReportTransactions(Transaction[] @transactions);
}

class UniffiCallbackInterfaceSyncUpdate
{
	static void UpdateStatus(ulong @uniffiHandle, RustBuffer @data, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
	{
		var handle = @uniffiHandle;
		if (FfiConverterTypeSyncUpdate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
		{
			uniffiObject.UpdateStatus(FfiConverterTypeSyncUpdateData.INSTANCE.Lift(@data));
		}
		else
		{
			throw new InternalException($"No callback in handlemap '{handle}'");
		}
	}

	static void ReportTransactions(
		ulong @uniffiHandle,
		RustBuffer @transactions,
		IntPtr @uniffiOutReturn,
		ref UniffiRustCallStatus _uniffi_out_err
	)
	{
		var handle = @uniffiHandle;
		if (FfiConverterTypeSyncUpdate.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
		{
			uniffiObject.ReportTransactions(FfiConverterSequenceTypeTransaction.INSTANCE.Lift(@transactions));
		}
		else
		{
			throw new InternalException($"No callback in handlemap '{handle}'");
		}
	}

	static void UniffiFree(ulong @handle)
	{
		FfiConverterTypeSyncUpdate.INSTANCE.handleMap.Remove(@handle);
	}

	static _UniFFILib.UniffiCallbackInterfaceSyncUpdateMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceSyncUpdateMethod0(UpdateStatus);
	static _UniFFILib.UniffiCallbackInterfaceSyncUpdateMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceSyncUpdateMethod1(
		ReportTransactions
	);
	static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

	public static _UniFFILib.UniffiVTableCallbackInterfaceSyncUpdate _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceSyncUpdate
	{
		@updateStatus = Marshal.GetFunctionPointerForDelegate(_m0),
		@reportTransactions = Marshal.GetFunctionPointerForDelegate(_m1),
		@uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free),
	};

	public static void Register()
	{
		_UniFFILib.uniffi_nerdbank_zcash_rust_fn_init_callback_vtable_syncupdate(ref UniffiCallbackInterfaceSyncUpdate._vtable);
	}
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSyncUpdate : FfiConverter<SyncUpdate, ulong>
{
	public static FfiConverterTypeSyncUpdate INSTANCE = new FfiConverterTypeSyncUpdate();

	public ConcurrentHandleMap<SyncUpdate> handleMap = new ConcurrentHandleMap<SyncUpdate>();

	public override ulong Lower(SyncUpdate value)
	{
		return handleMap.Insert(value);
	}

	public override SyncUpdate Lift(ulong value)
	{
		if (handleMap.TryGet(value, out var uniffiCallback))
		{
			return uniffiCallback;
		}
		else
		{
			throw new InternalException($"No callback in handlemap '{value}'");
		}
	}

	public override SyncUpdate Read(BigEndianStream stream)
	{
		return Lift(stream.ReadULong());
	}

	public override int AllocationSize(SyncUpdate value)
	{
		return 8;
	}

	public override void Write(SyncUpdate value, BigEndianStream stream)
	{
		stream.WriteULong(Lower(value));
	}
}

class FfiConverterOptionalUInt32 : FfiConverterRustBuffer<uint?>
{
	public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

	public override uint? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterUInt32.INSTANCE.Read(stream);
	}

	public override int AllocationSize(uint? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
		}
	}

	public override void Write(uint? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
		}
	}
}

class FfiConverterOptionalUInt64 : FfiConverterRustBuffer<ulong?>
{
	public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

	public override ulong? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterUInt64.INSTANCE.Read(stream);
	}

	public override int AllocationSize(ulong? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
		}
	}

	public override void Write(ulong? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
		}
	}
}

class FfiConverterOptionalString : FfiConverterRustBuffer<string?>
{
	public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

	public override string? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterString.INSTANCE.Read(stream);
	}

	public override int AllocationSize(string? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
		}
	}

	public override void Write(string? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterString.INSTANCE.Write((string)value, stream);
		}
	}
}

class FfiConverterOptionalByteArray : FfiConverterRustBuffer<byte[]?>
{
	public static FfiConverterOptionalByteArray INSTANCE = new FfiConverterOptionalByteArray();

	public override byte[]? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterByteArray.INSTANCE.Read(stream);
	}

	public override int AllocationSize(byte[]? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterByteArray.INSTANCE.AllocationSize((byte[])value);
		}
	}

	public override void Write(byte[]? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterByteArray.INSTANCE.Write((byte[])value, stream);
		}
	}
}

class FfiConverterOptionalTimestamp : FfiConverterRustBuffer<DateTime?>
{
	public static FfiConverterOptionalTimestamp INSTANCE = new FfiConverterOptionalTimestamp();

	public override DateTime? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterTimestamp.INSTANCE.Read(stream);
	}

	public override int AllocationSize(DateTime? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterTimestamp.INSTANCE.AllocationSize((DateTime)value);
		}
	}

	public override void Write(DateTime? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterTimestamp.INSTANCE.Write((DateTime)value, stream);
		}
	}
}

class FfiConverterOptionalTypeCancellationSource : FfiConverterRustBuffer<CancellationSource?>
{
	public static FfiConverterOptionalTypeCancellationSource INSTANCE = new FfiConverterOptionalTypeCancellationSource();

	public override CancellationSource? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterTypeCancellationSource.INSTANCE.Read(stream);
	}

	public override int AllocationSize(CancellationSource? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterTypeCancellationSource.INSTANCE.AllocationSize((CancellationSource)value);
		}
	}

	public override void Write(CancellationSource? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterTypeCancellationSource.INSTANCE.Write((CancellationSource)value, stream);
		}
	}
}

class FfiConverterOptionalTypeSyncUpdate : FfiConverterRustBuffer<SyncUpdate?>
{
	public static FfiConverterOptionalTypeSyncUpdate INSTANCE = new FfiConverterOptionalTypeSyncUpdate();

	public override SyncUpdate? Read(BigEndianStream stream)
	{
		if (stream.ReadByte() == 0)
		{
			return null;
		}
		return FfiConverterTypeSyncUpdate.INSTANCE.Read(stream);
	}

	public override int AllocationSize(SyncUpdate? value)
	{
		if (value == null)
		{
			return 1;
		}
		else
		{
			return 1 + FfiConverterTypeSyncUpdate.INSTANCE.AllocationSize((SyncUpdate)value);
		}
	}

	public override void Write(SyncUpdate? value, BigEndianStream stream)
	{
		if (value == null)
		{
			stream.WriteByte(0);
		}
		else
		{
			stream.WriteByte(1);
			FfiConverterTypeSyncUpdate.INSTANCE.Write((SyncUpdate)value, stream);
		}
	}
}

class FfiConverterSequenceTypeAccountInfo : FfiConverterRustBuffer<AccountInfo[]>
{
	public static FfiConverterSequenceTypeAccountInfo INSTANCE = new FfiConverterSequenceTypeAccountInfo();

	public override AccountInfo[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new AccountInfo[(length)];
		var readFn = FfiConverterTypeAccountInfo.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(AccountInfo[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeAccountInfo.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(AccountInfo[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeAccountInfo.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}

class FfiConverterSequenceTypeSendTransactionResult : FfiConverterRustBuffer<SendTransactionResult[]>
{
	public static FfiConverterSequenceTypeSendTransactionResult INSTANCE = new FfiConverterSequenceTypeSendTransactionResult();

	public override SendTransactionResult[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new SendTransactionResult[(length)];
		var readFn = FfiConverterTypeSendTransactionResult.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(SendTransactionResult[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeSendTransactionResult.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(SendTransactionResult[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeSendTransactionResult.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}

class FfiConverterSequenceTypeTransaction : FfiConverterRustBuffer<Transaction[]>
{
	public static FfiConverterSequenceTypeTransaction INSTANCE = new FfiConverterSequenceTypeTransaction();

	public override Transaction[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new Transaction[(length)];
		var readFn = FfiConverterTypeTransaction.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(Transaction[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeTransaction.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(Transaction[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeTransaction.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}

class FfiConverterSequenceTypeTransactionNote : FfiConverterRustBuffer<TransactionNote[]>
{
	public static FfiConverterSequenceTypeTransactionNote INSTANCE = new FfiConverterSequenceTypeTransactionNote();

	public override TransactionNote[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new TransactionNote[(length)];
		var readFn = FfiConverterTypeTransactionNote.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(TransactionNote[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeTransactionNote.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(TransactionNote[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeTransactionNote.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}

class FfiConverterSequenceTypeTransactionSendDetail : FfiConverterRustBuffer<TransactionSendDetail[]>
{
	public static FfiConverterSequenceTypeTransactionSendDetail INSTANCE = new FfiConverterSequenceTypeTransactionSendDetail();

	public override TransactionSendDetail[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new TransactionSendDetail[(length)];
		var readFn = FfiConverterTypeTransactionSendDetail.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(TransactionSendDetail[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeTransactionSendDetail.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(TransactionSendDetail[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeTransactionSendDetail.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}

class FfiConverterSequenceTypeTransparentNote : FfiConverterRustBuffer<TransparentNote[]>
{
	public static FfiConverterSequenceTypeTransparentNote INSTANCE = new FfiConverterSequenceTypeTransparentNote();

	public override TransparentNote[] Read(BigEndianStream stream)
	{
		var length = stream.ReadInt();
		if (length == 0)
		{
			return [];
		}

		var result = new TransparentNote[(length)];
		var readFn = FfiConverterTypeTransparentNote.INSTANCE.Read;
		for (int i = 0; i < length; i++)
		{
			result[i] = readFn(stream);
		}
		return result;
	}

	public override int AllocationSize(TransparentNote[] value)
	{
		var sizeForLength = 4;

		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			return sizeForLength;
		}

		var allocationSizeFn = FfiConverterTypeTransparentNote.INSTANCE.AllocationSize;
		var sizeForItems = value.Sum(item => allocationSizeFn(item));
		return sizeForLength + sizeForItems;
	}

	public override void Write(TransparentNote[] value, BigEndianStream stream)
	{
		// details/1-empty-list-as-default-method-parameter.md
		if (value == null)
		{
			stream.WriteInt(0);
			return;
		}

		stream.WriteInt(value.Length);
		var writerFn = FfiConverterTypeTransparentNote.INSTANCE.Write;
		value.ForEach(item => writerFn(item, stream));
	}
}
#pragma warning restore 8625
internal static class LightWalletMethods
{
	/// <exception cref="LightWalletException"></exception>
	public static byte[] AddAccount(
		DbInit @config,
		string @uri,
		string @name,
		byte[] @seed,
		uint @accountIndex,
		uint? @birthdayHeight,
		CancellationSource? @cancellation
	)
	{
		return FfiConverterByteArray.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_add_account(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterString.INSTANCE.Lower(@name),
						FfiConverterByteArray.INSTANCE.Lower(@seed),
						FfiConverterUInt32.INSTANCE.Lower(@accountIndex),
						FfiConverterOptionalUInt32.INSTANCE.Lower(@birthdayHeight),
						FfiConverterOptionalTypeCancellationSource.INSTANCE.Lower(@cancellation),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static string AddDiversifier(DbInit @config, byte[] @accountId, byte[] @diversifierIndex)
	{
		return FfiConverterString.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_add_diversifier(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						FfiConverterByteArray.INSTANCE.Lower(@diversifierIndex),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static void Cancel(uint @id)
	{
		_UniffiHelpers.RustCallWithError(
			FfiConverterTypeLightWalletError.INSTANCE,
			(ref UniffiRustCallStatus _status) =>
				_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_cancel(FfiConverterUInt32.INSTANCE.Lower(@id), ref _status)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static bool DisconnectServer(string @uri)
	{
		return FfiConverterBoolean.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_disconnect_server(FfiConverterString.INSTANCE.Lower(@uri), ref _status)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static AccountInfo[] GetAccounts(DbInit @config)
	{
		return FfiConverterSequenceTypeAccountInfo.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_accounts(FfiConverterTypeDbInit.INSTANCE.Lower(@config), ref _status)
			)
		);
	}

	/// <summary>
	/// Gets the oldest birthday height for any account in the wallet.
	/// </summary>
	/// <exception cref="LightWalletException"></exception>
	public static uint? GetBirthdayHeight(DbInit @config)
	{
		return FfiConverterOptionalUInt32.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_birthday_height(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static BirthdayHeights GetBirthdayHeights(DbInit @config, byte[] @accountId)
	{
		return FfiConverterTypeBirthdayHeights.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_birthday_heights(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static uint GetBlockHeight(string @uri, CancellationSource? @cancellation)
	{
		return FfiConverterUInt32.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_block_height(
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterOptionalTypeCancellationSource.INSTANCE.Lower(@cancellation),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static uint? GetSyncHeight(DbInit @config)
	{
		return FfiConverterOptionalUInt32.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_sync_height(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static Transaction[] GetTransactions(DbInit @config, byte[] @accountId, uint @startingBlock)
	{
		return FfiConverterSequenceTypeTransaction.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_transactions(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						FfiConverterUInt32.INSTANCE.Lower(@startingBlock),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static TransparentNote[] GetUnshieldedUtxos(DbInit @config, byte[] @accountId)
	{
		return FfiConverterSequenceTypeTransparentNote.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_unshielded_utxos(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static UserBalances GetUserBalances(DbInit @config, byte[] @accountId)
	{
		return FfiConverterTypeUserBalances.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_get_user_balances(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static byte[] ImportAccountUfvk(
		DbInit @config,
		string @uri,
		string @name,
		string @ufvk,
		bool @spendingKeyAvailable,
		uint? @birthdayHeight,
		CancellationSource? @cancellation
	)
	{
		return FfiConverterByteArray.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_import_account_ufvk(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterString.INSTANCE.Lower(@name),
						FfiConverterString.INSTANCE.Lower(@ufvk),
						FfiConverterBoolean.INSTANCE.Lower(@spendingKeyAvailable),
						FfiConverterOptionalUInt32.INSTANCE.Lower(@birthdayHeight),
						FfiConverterOptionalTypeCancellationSource.INSTANCE.Lower(@cancellation),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static void Init(DbInit @config)
	{
		_UniffiHelpers.RustCallWithError(
			FfiConverterTypeLightWalletError.INSTANCE,
			(ref UniffiRustCallStatus _status) =>
				_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_init(FfiConverterTypeDbInit.INSTANCE.Lower(@config), ref _status)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static SendTransactionResult[] Send(DbInit @config, string @uri, byte[] @usk, TransactionSendDetail[] @sendDetails)
	{
		return FfiConverterSequenceTypeSendTransactionResult.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_send(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterByteArray.INSTANCE.Lower(@usk),
						FfiConverterSequenceTypeTransactionSendDetail.INSTANCE.Lower(@sendDetails),
						ref _status
					)
			)
		);
	}

	/// <exception cref="LightWalletException"></exception>
	public static SendTransactionResult[] Shield(
		DbInit @config,
		string @uri,
		byte[] @accountId,
		byte[] @usk,
		string? @address,
		ulong @shieldingThreshold,
		byte[]? @memo
	)
	{
		return FfiConverterSequenceTypeSendTransactionResult.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_shield(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterByteArray.INSTANCE.Lower(@accountId),
						FfiConverterByteArray.INSTANCE.Lower(@usk),
						FfiConverterOptionalString.INSTANCE.Lower(@address),
						FfiConverterUInt64.INSTANCE.Lower(@shieldingThreshold),
						FfiConverterOptionalByteArray.INSTANCE.Lower(@memo),
						ref _status
					)
			)
		);
	}

	/// <summary>
	/// Constructs a proposal for how a given spend can be executed, and returns details for how it would work.
	/// </summary>
	/// <exception cref="LightWalletException"></exception>
	public static SendDetails SimulateSend(DbInit @config, string @ufvk, TransactionSendDetail[] @sendDetails)
	{
		return FfiConverterTypeSendDetails.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_simulate_send(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@ufvk),
						FfiConverterSequenceTypeTransactionSendDetail.INSTANCE.Lower(@sendDetails),
						ref _status
					)
			)
		);
	}

	/// <summary>
	/// Downloads blocks from the blockchain, scans them for transactions, and updates the database.
	/// If `continually` is `true`, this function will never exit unless cancellation is signaled.
	/// </summary>
	/// <exception cref="LightWalletException"></exception>
	public static SyncUpdateData Sync(
		DbInit @config,
		string @uri,
		SyncUpdate? @progress,
		bool @continually,
		CancellationSource? @cancellation
	)
	{
		return FfiConverterTypeSyncUpdateData.INSTANCE.Lift(
			_UniffiHelpers.RustCallWithError(
				FfiConverterTypeLightWalletError.INSTANCE,
				(ref UniffiRustCallStatus _status) =>
					_UniFFILib.uniffi_nerdbank_zcash_rust_fn_func_sync(
						FfiConverterTypeDbInit.INSTANCE.Lower(@config),
						FfiConverterString.INSTANCE.Lower(@uri),
						FfiConverterOptionalTypeSyncUpdate.INSTANCE.Lower(@progress),
						FfiConverterBoolean.INSTANCE.Lower(@continually),
						FfiConverterOptionalTypeCancellationSource.INSTANCE.Lower(@cancellation),
						ref _status
					)
			)
		);
	}
}
